{
    "docs": [
        {
            "location": "/", 
            "text": "Oceananigans.jl Documentation\n\n\n\n\nGrids\n\n\n#\n\n\nOceananigans.RegularCartesianGrid\n \n \nType\n.\n\n\nRegularCartesianGrid\n\n\n\n\n\nA Cartesian grid with regularly spaces cells and faces so that $\u0394x$, $\u0394y$, and $\u0394z$ are constants. Fields are stored using floating-point values of type T.\n\n\nsource\n\n\n#\n\n\nOceananigans.RegularCartesianGrid\n \n \nMethod\n.\n\n\nRegularCartesianGrid(metadata::ModelMetadata, N, L)\n\n\n\n\n\nCreate a regular Cartesian grid with size $N = (N_x, N_y, N_z)$ and domain size $L = (L_x, L_y, L_z)$ where fields are stored using floating-point values of type T.\n\n\nExamples\n\n\njulia\n g = RegularCartesianGrid((16, 16, 8), (2\u03c0, 2\u03c0, 2\u03c0))\n\n\n\n\n\nsource\n\n\n\n\nFields\n\n\n#\n\n\nOceananigans.CellField\n \n \nType\n.\n\n\nCellField{T,G\n:Grid{T}} \n: Field{G}\n\n\n\n\n\nA cell-centered field defined on a grid \nG\n whose values are stored as floating-point values of type T.\n\n\nsource\n\n\n#\n\n\nOceananigans.FaceFieldX\n \n \nType\n.\n\n\nFaceFieldX{T,G\n:Grid{T}} \n: FaceField{G}\n\n\n\n\n\nAn x-face-centered field defined on a grid \nG\n whose values are stored as floating-point values of type T.\n\n\nsource\n\n\n#\n\n\nOceananigans.FaceFieldY\n \n \nType\n.\n\n\nFaceFieldY{T,G\n:Grid{T}} \n: FaceField{G}\n\n\n\n\n\nA y-face-centered field defined on a grid \nG\n whose values are stored as floating-point values of type T.\n\n\nsource\n\n\n#\n\n\nOceananigans.FaceFieldZ\n \n \nType\n.\n\n\nFaceFieldZ{T,G\n:Grid{T}} \n: FaceField{G}\n\n\n\n\n\nA z-face-centered field defined on a grid \nG\n whose values are stored as floating-point values of type T.\n\n\nsource\n\n\n\n\nOperators\n\n\n\n\nDifference operators\n\n\n\u03b4x!(g::RegularCartesianGrid, f::CellField, \u03b4xf::FaceField)\n\u03b4x!(g::RegularCartesianGrid, f::FaceField, \u03b4xf::CellField)\n\u03b4y!(g::RegularCartesianGrid, f::CellField, \u03b4yf::FaceField)\n\u03b4y!(g::RegularCartesianGrid, f::FaceField, \u03b4yf::CellField)\n\u03b4z!(g::RegularCartesianGrid, f::CellField, \u03b4zf::FaceField)\n\u03b4z!(g::RegularCartesianGrid, f::FaceField, \u03b4zf::CellField)\n\n\n\n\n\n\n\nAveraging operators\n\n\navgx!(g::RegularCartesianGrid, f::CellField, favgx::FaceField)\n\n\n\n\n\n\n\nDivergence operators\n\n\nBuilding on top of the differencing operators we can define operators that compute the divergence\n\n\n\n\n\n\\nabla\\cdotp\\mathbf{f} = \\frac{1}{V} \\left[ \\delta_x \\left( A_x f_x \\right)\n+ \\delta_y\\left( A_y f_y \\right) + \\delta_z\\left( A_z f_z \\right)\\right]", 
            "title": "Home"
        }, 
        {
            "location": "/#oceananigansjl-documentation", 
            "text": "", 
            "title": "Oceananigans.jl Documentation"
        }, 
        {
            "location": "/#grids", 
            "text": "#  Oceananigans.RegularCartesianGrid     Type .  RegularCartesianGrid  A Cartesian grid with regularly spaces cells and faces so that $\u0394x$, $\u0394y$, and $\u0394z$ are constants. Fields are stored using floating-point values of type T.  source  #  Oceananigans.RegularCartesianGrid     Method .  RegularCartesianGrid(metadata::ModelMetadata, N, L)  Create a regular Cartesian grid with size $N = (N_x, N_y, N_z)$ and domain size $L = (L_x, L_y, L_z)$ where fields are stored using floating-point values of type T.  Examples  julia  g = RegularCartesianGrid((16, 16, 8), (2\u03c0, 2\u03c0, 2\u03c0))  source", 
            "title": "Grids"
        }, 
        {
            "location": "/#fields", 
            "text": "#  Oceananigans.CellField     Type .  CellField{T,G :Grid{T}}  : Field{G}  A cell-centered field defined on a grid  G  whose values are stored as floating-point values of type T.  source  #  Oceananigans.FaceFieldX     Type .  FaceFieldX{T,G :Grid{T}}  : FaceField{G}  An x-face-centered field defined on a grid  G  whose values are stored as floating-point values of type T.  source  #  Oceananigans.FaceFieldY     Type .  FaceFieldY{T,G :Grid{T}}  : FaceField{G}  A y-face-centered field defined on a grid  G  whose values are stored as floating-point values of type T.  source  #  Oceananigans.FaceFieldZ     Type .  FaceFieldZ{T,G :Grid{T}}  : FaceField{G}  A z-face-centered field defined on a grid  G  whose values are stored as floating-point values of type T.  source", 
            "title": "Fields"
        }, 
        {
            "location": "/#operators", 
            "text": "", 
            "title": "Operators"
        }, 
        {
            "location": "/#difference-operators", 
            "text": "\u03b4x!(g::RegularCartesianGrid, f::CellField, \u03b4xf::FaceField)\n\u03b4x!(g::RegularCartesianGrid, f::FaceField, \u03b4xf::CellField)\n\u03b4y!(g::RegularCartesianGrid, f::CellField, \u03b4yf::FaceField)\n\u03b4y!(g::RegularCartesianGrid, f::FaceField, \u03b4yf::CellField)\n\u03b4z!(g::RegularCartesianGrid, f::CellField, \u03b4zf::FaceField)\n\u03b4z!(g::RegularCartesianGrid, f::FaceField, \u03b4zf::CellField)", 
            "title": "Difference operators"
        }, 
        {
            "location": "/#averaging-operators", 
            "text": "avgx!(g::RegularCartesianGrid, f::CellField, favgx::FaceField)", 
            "title": "Averaging operators"
        }, 
        {
            "location": "/#divergence-operators", 
            "text": "Building on top of the differencing operators we can define operators that compute the divergence   \n\\nabla\\cdotp\\mathbf{f} = \\frac{1}{V} \\left[ \\delta_x \\left( A_x f_x \\right)\n+ \\delta_y\\left( A_y f_y \\right) + \\delta_z\\left( A_z f_z \\right)\\right]", 
            "title": "Divergence operators"
        }
    ]
}